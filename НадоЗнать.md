### a link
Ошибка связанная с безопасностью.
Если вы создаете ссылку с target='_blank' атрибутом не забудьте добавить к ней rel='noreferrer noopener'. Очень просто:
<a href="https://example.com" target="_blank" rel="noreferrer noopener" />

### 
В случае stateless компонента функцию можно вынести наружу, иначе она будет создаваться каждый раз заново при перерендере компонента.


### componentDidMount()
Как только вывод рендера Clock вставлен в DOM, React вызывает метод жизненного цикла componentDidMount(). Внутри него компонент Clock меняет "state".React реагирует на изменение состояния и снова запускает render(). На этот раз this.state.date в методе render() содержит новое значение, поэтому React заменит DOM. 

### new setState! 
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));


### распространенная ошибка 
передача'style' и 'className' как props в ваш компонент. Избегайте этого, так как вы добавите много сложности в ваши компоненты.


### prop key 
React использует prop key как ссылку к DOM элементу, и это помогает ему быстро найти и отрендерить нужный компонент (все, конечно, сложнее, но я упростил специально).
Что случиться если вы добавите нового юзера в середину массива? React будет вынужден перерендерить все UserComponents после добавленного нового, так как индекс будет изменен для большого кол-ва компонентов. Используйте уникальные ключи вместо этого. Очень простой выход это id, которые вы получаете из вашей базы данных:
users.map((user) => (
  <UserComponent {...user} key={user.id}  />
));


### no bind.this 
Очень распространенная и большая ошибка которую я видел в коде много раз. Не Используйте Bind. Никогда. Больше.
Самое жаркое место в аду ждет того кто пишет .bind(this) в JSX в обработчике событий.
Каждый раз когда компонент рендериться ваша функция будет создаваться заново, и это может сильно затормозить ваше приложение (это связано с тем, что garbage collector будет вынужден запускаться значительно чаще). Вместо .bind(this) вы можете использовать Arrow functions определенным образом:
# ------------
const handleDivClick = (event) => event;
const AndInPureComponent = () => {
    return <div onClick={handleDivClick} />
}
### Պետք չէ կլասի անունը փոխանցել "props"-ով, այլընտրանքային կարելի է օգտագործել 
### "classnames" գրադարանը 
#  https://github.com/JedWatson/classnames
# ------------ օրինակ
var classNames = require('classnames');

class Button extends React.Component {
  // ...
  render () {
    var btnClass = classNames({
      btn: true,
      'btn-pressed': this.state.isPressed,
      'btn-over': !this.state.isPressed && this.state.isHovered
    });
    return <button className={btnClass}>{this.props.label}</button>;
  }
} 

### AJAX и обращение к API 
https://ru.reactjs.org/docs/faq-ajax.html#gatsby-focus-wrapper