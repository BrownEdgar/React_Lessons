# virtual DOM

Ինչի համար է React.js-ը ստեղծում ևս մեկ DOM, որովհետև `virtual DOM` -ը կարող ենք թարմացնել ավելի շատ քան իրական DOM-ը։Մենք դրա շնորհիվ կարող ենք կուտակել DOM փոփոխությունները հետո մեկ անգամ թարմացնել իրական DOM-ը։Օրինակ 500 անգամ կարող ենք update անել `virtual DOM` -ը
բայց իրական DOM-ը update անել ընդամենը 60 անգամ։ Ինչի հենց 60?:Որվհետև մարդու աչքը դրանից ավել չի կարող նկատել ՝60fps՝

- Ошибка связанная с безопасностью.
  Если вы создаете ссылку с target='\_blank' атрибутом не забудьте добавить к ней rel='noreferrer noopener'. Очень просто:
  <a href="https://example.com" target="_blank" rel="noreferrer noopener" />

В случае stateless компонента функцию можно вынести наружу, иначе она будет создаваться каждый раз заново при перерендере компонента.

## componentDidMount()

Как только вывод рендера Clock вставлен в DOM, React вызывает метод жизненного цикла componentDidMount(). Внутри него компонент Clock меняет "state".React реагирует на изменение состояния и снова запускает render(). На этот раз this.state.date в методе render() содержит новое значение, поэтому React заменит DOM.

### new setState

this.setState((state, props) => ({
counter: state.counter + props.increment
}));

### распространенная ошибка

передача'style' и 'className' как props в ваш компонент. Избегайте этого, так как вы добавите много сложности в ваши компоненты.

### prop key

React использует prop key как ссылку к DOM элементу, и это помогает ему быстро найти и отрендерить нужный компонент.
Что случиться если вы добавите нового юзера в середину массива? React будет вынужден перерендерить все UserComponents после добавленного нового, так как индекс будет изменен для большого кол-ва компонентов. Используйте уникальные ключи вместо этого. Очень простой выход это id, которые вы получаете из вашей базы данных:
users.map((user) => (
<UserComponent {...user} key={user.id} />
));

### no bind.this

Очень распространенная и большая ошибка которую я видел в коде много раз. Не Используйте Bind. Никогда. Больше.
Самое жаркое место в аду ждет того кто пишет .bind(this) в JSX в обработчике событий.
Каждый раз когда компонент рендериться ваша функция будет создаваться заново, и это может сильно затормозить ваше приложение (это связано с тем, что garbage collector будет вынужден запускаться значительно чаще). Вместо .bind(this) вы можете использовать Arrow functions определенным образом:

### օրինակ

var classNames = require('classnames');
class Button extends React.Component {
// ...
render () {
var btnClass = classNames({
btn: true,
'btn-pressed': this.state.isPressed,
'btn-over': !this.state.isPressed && this.state.isHovered
});
return <button className={btnClass}>{this.props.label}</button>;
}
}

### AJAX и обращение к API

<https://ru.reactjs.org/docs/faq-ajax.html#gatsby-focus-wrapper>

## Файл robots.txt

- В файле robots.txt содержатся инструкции, которые говорят поисковым роботам, какие URL на вашем сайте им разрешено обрабатывать. С его помощью можно ограничить количество запросов на сканирование и тем самым снизить нагрузку на сайт. Файл robots.txt не предназначен для того, чтобы запрещать показ ваших материалов в результатах поиска Google.
- Файл robots.txt вместе с xml-картой несёт, пожалуй, самую важную информацию о ресурсе: он показывает роботам поисковых систем, как именно «читать» сайт, какие страницы важны, а какие следует пропустить. Еще robots.txt — первая страница, на которую стоит смотреть, если на сайт внезапно упал трафик..
- Файл robots.txt или индексный файл — обычный текстовый документ в кодировке UTF-8, действует для протоколов http, https, а также FTP. Файл дает поисковым роботам рекомендации: какие страницы/файлы стоит сканировать
- При обработке правил в файле robots.txt поисковые роботы получают одну из трех инструкций:
  частичный доступ: доступно сканирование отдельных элементов сайта;
  полный доступ: сканировать можно все;
  полный запрет: робот ничего не может сканировать.

read more => [(https://netpeak.net/ru/blog/chto-takoe-robots-txt-i-zachem-on-voobshche-nuzhen/)]

### rename all _.js files containing React markup to_.jsx

- in cli
  find ./src -type f -name '_.js' -not -name '_.jsx' -not -name '\*.ejs' -exec bash -c 'grep -l -E "</|/>" "$0"' {} \; -exec bash -c 'mv "$0" "${0%.js}.jsx"' {} \;
